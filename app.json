import { 
  StyleSheet, 
  Text, 
  View, 
  ScrollView, 
  TouchableOpacity, 
  TextInput,
  ActivityIndicator,
  Alert,
  Modal,
  Platform
} from "react-native";
import { Stack } from "expo-router";
import { AlertTriangle, MessageCircle, Newspaper, Send, Copy, Save, X, Trash2, Shield, Brain, Settings } from "lucide-react-native";
import React, { useState, useMemo, useCallback } from "react";
import * as Clipboard from "expo-clipboard";

type ResponseMode = "crisis" | "interview" | "news" | "talking-points";
type AIProvider = "deepseek" | "openai" | "anthropic" | "google";

type SavedResponse = {
  id: string;
  mode: ResponseMode;
  situation: string;
  response: string;
  date: string;
};

type AIConfig = {
  provider: AIProvider;
  apiKey: string;
  model: string;
  baseURL?: string;
};

export default function CrisisResponseScreen() {
  const [selectedMode, setSelectedMode] = useState<ResponseMode>("crisis");
  const [situation, setSituation] = useState<string>("");
  const [generatedResponse, setGeneratedResponse] = useState<string>("");
  const [isGenerating, setIsGenerating] = useState<boolean>(false);
  const [savedResponses, setSavedResponses] = useState<SavedResponse[]>([]);
  const [showSavedModal, setShowSavedModal] = useState<boolean>(false);
  const [showAIConfigModal, setShowAIConfigModal] = useState<boolean>(false);
  const [aiConfig, setAIConfig] = useState<AIConfig>({
    provider: "deepseek",
    apiKey: "",
    model: "deepseek-chat",
    baseURL: "https://api.deepseek.com/v1"
  });

  const providers = [
    { 
      id: "deepseek" as AIProvider, 
      name: "DeepSeek", 
      models: ["deepseek-chat", "deepseek-coder"],
      defaultBaseURL: "https://api.deepseek.com/v1"
    },
    { 
      id: "openai" as AIProvider, 
      name: "OpenAI", 
      models: ["gpt-4", "gpt-4-turbo", "gpt-3.5-turbo"],
      defaultBaseURL: "https://api.openai.com/v1"
    },
    { 
      id: "anthropic" as AIProvider, 
      name: "Anthropic", 
      models: ["claude-3-opus", "claude-3-sonnet", "claude-3-haiku"],
      defaultBaseURL: "https://api.anthropic.com/v1"
    },
    { 
      id: "google" as AIProvider, 
      name: "Google", 
      models: ["gemini-pro", "gemini-ultra"],
      defaultBaseURL: "https://generativelanguage.googleapis.com/v1"
    },
  ];

  const modes = useMemo(() => [
    { 
      id: "crisis" as ResponseMode, 
      label: "Gestão de Crise", 
      icon: AlertTriangle,
      color: "#dc2626" 
    },
    { 
      id: "interview" as ResponseMode, 
      label: "Treino de Entrevista", 
      icon: MessageCircle,
      color: "#2563eb" 
    },
    { 
      id: "news" as ResponseMode, 
      label: "Resposta a Notícia", 
      icon: Newspaper,
      color: "#8b5cf6" 
    },
    { 
      id: "talking-points" as ResponseMode, 
      label: "Talking Points", 
      icon: Shield,
      color: "#10b981" 
    },
  ], []);

  const getPromptPlaceholder = useCallback(() => {
    switch (selectedMode) {
      case "crisis":
        return "Descreva a situação de crise que precisa gerir...";
      case "interview":
        return "Descreva as perguntas ou tópicos da entrevista...";
      case "news":
        return "Cole o texto da notícia ou descreva o acontecimento...";
      case "talking-points":
        return "Descreva o tema para o qual precisa de pontos-chave...";
      default:
        return "Descreva a situação...";
    }
  }, [selectedMode]);

  const getSystemPromptForMode = useCallback((mode: ResponseMode): string => {
    const prompts = {
      crisis: `Você é um consultor especializado em gestão de crises políticas com 20 anos de experiência. 
Analise a situação de crise descrita e forneça uma resposta estratégica completa:

**ANÁLISE DA CRISE:**
- Avaliação de risco (Alto/Médio/Baixo) e impacto potencial
- Stakeholders principais afetados
- Sensibilidade mediática estimada

**ESTRATÉGIA IMEDIATA (Primeiras 24h):**
- Comunicado oficial recomendado
- Cronograma de ações prioritárias
- Canais de comunicação a utilizar

**MENSAGEM-CHAVE:**
- Posicionamento central
- Tom e linguagem recomendados
- Pontos não negociáveis

**RESPOSTAS A PERGUNTAS DIFÍCEIS:**
- 3-5 perguntas previsíveis com respostas preparadas
- Técnicas de redirecionamento
- Factos de apoio

**AÇÕES CONCRETAS:**
- Medidas operacionais imediatas
- Monitorização recomendada
- Próximos passos estratégicos

**ARMADILHAS A EVITAR:**
- Declarações problemáticas
- Comportamentos de risco
- Oportunidades perdidas

Seja prático, específico e acionável. Use português de Portugal formal mas acessível.`,

      interview: `Você é um treinador de comunicação política com vasta experiência em preparação de entrevistas. 
Forneça uma preparação completa:

**ANÁLISE DO CONTEXTO:**
- Objetivos da entrevista
- Público-alvo e meio de comunicação
- Tom e estilo apropriados

**PERGUNTAS PREVISÍVEIS:**
- Lista de 5-8 perguntas prováveis
- Classificação por dificuldade
- Ângulos de abordagem

**RESPOSTAS ESTRUTURADAS:**
- 3-5 respostas modelo completas
- Estrutura: Ponte → Mensagem → Evidência → Call-to-action
- Duração ideal por resposta (15-45 segundos)

**TÉCNICAS DE COMUNICAÇÃO:**
- Linguagem corporal recomendada
- Controlo de ritmo e pausas
- Gestão de interrupções

**PONTOS-CHAVE A INCORPORAR:**
- 3 mensagens principais obrigatórias
- Dados e estatísticas de apoio
- Histórias ou exemplos relevantes

**CENÁRIOS DE CRISE:**
- Respostas para perguntas agressivas
- Gestão de assuntos sensíveis
- Saídas elegantes para temas complexos

As respostas devem soar naturais, autênticas e convincentes.`,

      news: `Você é um estrategista sénior de comunicação política especializado em gestão de notícias.
Forneça uma resposta completa:

**ANÁLISE DA NOTÍCIA:**
- Factos principais e contexto
- Potencial impacto (positivo/negativo/neutro)
- Ângulo mediático predominante

**RESPOSTA ESTRATÉGICA:**
- Posicionamento recomendado
- Tom e linguagem apropriados
- Timing de resposta ideal

**COMUNICADO OFICIAL:**
- Declaração completa (250-400 palavras)
- Estrutura: Agradecimento → Factos → Contexto → Compromisso → Futuro
- Versões para diferentes canais

**PLANO DE COMUNICAÇÃO:**
- Canais prioritários (imprensa, redes sociais, site)
- Sequência de comunicações
- Mensagens adaptadas por canal

**FAQ COMPLETO:**
- 8-12 perguntas previsíveis
- Respostas detalhadas e consistentes
- Informação adicional de apoio

**MONITORIZAÇÃO E FOLLOW-UP:**
- Indicadores de performance
- Ajustes estratégicos possíveis
- Próximos passos de comunicação

Mantenha coerência, transparência e profissionalismo.`,

      talkingPoints: `Você é um especialista em desenvolvimento de mensagens políticas estratégicas.
Crie talking points completos e eficazes:

**ANÁLISE DO TEMA:**
- Contexto e importância
- Públicos-alvo primários e secundários
- Objetivos de comunicação

**PONTOS-CHAVE PRINCIPAIS:**
- 5-7 mensagens centrais memoráveis
- Hierarquia por importância
- Adaptação por audiência

**ARGUMENTÁRIO COMPLETO:**
- Evidências e dados de apoio para cada ponto
- Estatísticas recentes e relevantes
- Casos de estudo ou exemplos concretos

**FRASES DE IMPACTO:**
- 10-15 frases prontas para usar
- Adaptáveis a diferentes contextos
- Memoráveis e compartilháveis

**RESPOSTA A OBJEÇÕES:**
- Contra-argumentos previsíveis
- Respostas baseadas em factos
- Técnicas de persuasão apropriadas

**CALL-TO-ACTION:**
- Ações específicas para o público
- Passos concretos e mensuráveis
- Envolvimento continuado

**MATERIAIS DE APOIO:**
- Dados adicionais para aprofundamento
- Fontes de verificação
- Recursos visuais sugeridos

Foque em clareza, impacto e facilidade de comunicação.`
    };

    return prompts[mode] || "Forneça uma resposta estratégica e profissional em português de Portugal.";
  }, []);

  const callAIApi = async (systemPrompt: string, userMessage: string): Promise<string> => {
    if (!aiConfig.apiKey) {
      throw new Error("Chave de API não configurada. Configure a IA primeiro.");
    }

    const provider = providers.find(p => p.id === aiConfig.provider);
    if (!provider) {
      throw new Error("Provedor de IA não suportado.");
    }

    const baseURL = aiConfig.baseURL || provider.defaultBaseURL;
    
    switch (aiConfig.provider) {
      case "deepseek":
      case "openai":
        return await callOpenAICompatibleAPI(baseURL, aiConfig.apiKey, aiConfig.model, systemPrompt, userMessage);
      
      case "anthropic":
        return await callAnthropicAPI(aiConfig.apiKey, aiConfig.model, systemPrompt, userMessage);
      
      case "google":
        return await callGoogleAPI(aiConfig.apiKey, aiConfig.model, systemPrompt, userMessage);
      
      default:
        throw new Error("Provedor de IA não implementado.");
    }
  };

  const callOpenAICompatibleAPI = async (
    baseURL: string, 
    apiKey: string, 
    model: string, 
    systemPrompt: string, 
    userMessage: string
  ): Promise<string> => {
    const response = await fetch(`${baseURL}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userMessage }
        ],
        temperature: 0.7,
        max_tokens: 4000,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      throw new Error(`Erro na API: ${response.status} - ${errorData?.error?.message || response.statusText}`);
    }

    const data = await response.json();
    return data.choices[0]?.message?.content || "Não foi possível gerar uma resposta.";
  };

  const callAnthropicAPI = async (
    apiKey: string, 
    model: string, 
    systemPrompt: string, 
    userMessage: string
  ): Promise<string> => {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: model,
        max_tokens: 4000,
        temperature: 0.7,
        system: systemPrompt,
        messages: [{ role: 'user', content: userMessage }]
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      throw new Error(`Erro na API Anthropic: ${response.status} - ${errorData?.error?.message || response.statusText}`);
    }

    const data = await response.json();
    return data.content[0]?.text || "Não foi possível gerar uma resposta.";
  };

  const callGoogleAPI = async (
    apiKey: string, 
    model: string, 
    systemPrompt: string, 
    userMessage: string
  ): Promise<string> => {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { text: systemPrompt },
              { text: userMessage }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 4000,
        }
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      throw new Error(`Erro na API Google: ${response.status} - ${errorData?.error?.message || response.statusText}`);
    }

    const data = await response.json();
    return data.candidates[0]?.content?.parts[0]?.text || "Não foi possível gerar uma resposta.";
  };

  const generateResponse = async () => {
    const trimmedSituation = situation.trim();
    
    if (!trimmedSituation) {
      Alert.alert("Atenção", "Por favor, descreva a situação primeiro.");
      return;
    }
    
    if (trimmedSituation.length < 10) {
      Alert.alert("Atenção", "Por favor, forneça uma descrição mais detalhada (mínimo 10 caracteres).");
      return;
    }

    if (!aiConfig.apiKey) {
      Alert.alert(
        "Configuração de IA Necessária",
        "Configure primeiro a sua chave de API para usar a IA.",
        [
          { text: "Cancelar", style: "cancel" },
          { text: "Configurar", onPress: () => setShowAIConfigModal(true) }
        ]
      );
      return;
    }
    
    setIsGenerating(true);
    setGeneratedResponse("");
    
    try {
      console.log("Gerando resposta com:", aiConfig.provider, selectedMode);
      
      const systemPrompt = getSystemPromptForMode(selectedMode);
      const userMessage = `Situação: ${trimmedSituation}\n\nPor favor, forneça uma resposta completa e bem estruturada em português de Portugal.`;
      
      const response = await callAIApi(systemPrompt, userMessage);
      
      if (!response || typeof response !== 'string') {
        throw new Error('Resposta da IA inválida');
      }
      
      console.log("Resposta gerada com sucesso");
      setGeneratedResponse(response);
    } catch (error) {
      console.error("Erro ao gerar resposta:", error);
      Alert.alert(
        "Erro na Geração", 
        error instanceof Error ? error.message : "Não foi possível gerar a resposta. Verifique a sua configuração de IA.",
        [{ text: "Configurar IA", onPress: () => setShowAIConfigModal(true) }]
      );
      setGeneratedResponse("");
    } finally {
      setIsGenerating(false);
    }
  };

  const saveResponse = () => {
    if (!generatedResponse) return;
    
    const newSavedResponse: SavedResponse = {
      id: Date.now().toString(),
      mode: selectedMode,
      situation: situation,
      response: generatedResponse,
      date: new Date().toISOString(),
    };
    
    setSavedResponses([newSavedResponse, ...savedResponses]);
    Alert.alert("Sucesso", "Resposta guardada com sucesso!");
  };

  const deleteResponse = (id: string) => {
    Alert.alert(
      "Eliminar Resposta",
      "Tem certeza que deseja eliminar esta resposta?",
      [
        {
          text: "Cancelar",
          style: "cancel",
        },
        {
          text: "Eliminar",
          style: "destructive",
          onPress: () => {
            setSavedResponses(savedResponses.filter((r) => r.id !== id));
            Alert.alert("Sucesso", "Resposta eliminada com sucesso!");
          },
        },
      ]
    );
  };

  const loadResponse = (saved: SavedResponse) => {
    setSelectedMode(saved.mode);
    setSituation(saved.situation);
    setGeneratedResponse(saved.response);
    setShowSavedModal(false);
  };

  const copyToClipboard = async () => {
    if (!generatedResponse) return;
    
    try {
      await Clipboard.setStringAsync(generatedResponse);
      Alert.alert("Sucesso", "Resposta copiada para a área de transferência!");
    } catch (error) {
      console.error("Erro ao copiar:", error);
      Alert.alert("Erro", "Não foi possível copiar a resposta.");
    }
  };

  const getModeColor = (modeId: ResponseMode) => {
    const mode = modes.find(m => m.id === modeId);
    return mode?.color || "#6b7280";
  };

  const getModeLabel = (modeId: ResponseMode) => {
    const mode = modes.find(m => m.id === modeId);
    return mode?.label || "";
  };

  const updateAIConfig = (field: keyof AIConfig, value: string) => {
    setAIConfig(prev => {
      const updated = { ...prev, [field]: value };
      
      // Atualizar baseURL quando o provider mudar
      if (field === 'provider') {
        const provider = providers.find(p => p.id === value as AIProvider);
        if (provider) {
          updated.baseURL = provider.defaultBaseURL;
          updated.model = provider.models[0];
        }
      }
      
      return updated;
    });
  };

  const testAIConnection = async () => {
    if (!aiConfig.apiKey) {
      Alert.alert("Erro", "Insira uma chave de API primeiro.");
      return;
    }

    setIsGenerating(true);
    try {
      const testPrompt = "Responda apenas com 'OK' se estiver a funcionar.";
      await callAIApi(testPrompt, "Teste de conexão");
      Alert.alert("Sucesso", "Conexão com a IA estabelecida com sucesso!");
    } catch (error) {
      Alert.alert("Erro", error instanceof Error ? error.message : "Falha na conexão com a IA.");
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <View style={styles.container}>
      <Stack.Screen 
        options={{ 
          title: "Gestão de Crises + IA",
          headerRight: () => (
            <View style={styles.headerButtons}>
              <TouchableOpacity 
                onPress={() => setShowAIConfigModal(true)}
                style={styles.headerButton}
              >
                <Brain size={20} color="#8b5cf6" />
              </TouchableOpacity>
              <TouchableOpacity 
                onPress={() => setShowSavedModal(true)}
                style={styles.headerButton}
              >
                <Text style={styles.headerButtonText}>
                  ({savedResponses.length})
                </Text>
              </TouchableOpacity>
            </View>
          ),
        }} 
      />
      
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Resposta Estratégica com IA</Text>
          <Text style={styles.headerSubtitle}>
            Gestão de crises, treino de entrevistas e respostas a notícias com IA avançada
          </Text>
        </View>

        {!aiConfig.apiKey && (
          <TouchableOpacity 
            style={styles.configAlert}
            onPress={() => setShowAIConfigModal(true)}
          >
            <Settings size={20} color="#ffffff" />
            <Text style={styles.configAlertText}>
              Configure a IA para começar a gerar respostas
            </Text>
          </TouchableOpacity>
        )}

        <View style={styles.modesGrid}>
          {modes.map((mode) => {
            const Icon = mode.icon;
            return (
              <TouchableOpacity
                key={mode.id}
                style={[
                  styles.modeCard,
                  selectedMode === mode.id && styles.modeCardActive,
                  { borderColor: selectedMode === mode.id ? mode.color : "#e5e7eb" }
                ]}
                onPress={() => setSelectedMode(mode.id)}
              >
                <View style={[styles.modeIcon, { backgroundColor: mode.color + "15" }]}>
                  <Icon size={20} color={mode.color} />
                </View>
                <Text
                  style={[
                    styles.modeLabel,
                    selectedMode === mode.id && { color: mode.color }
                  ]}
                >
                  {mode.label}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

        <View style={styles.inputSection}>
          <Text style={styles.inputLabel}>Descreva a Situação</Text>
          <TextInput
            style={styles.textArea}
            placeholder={getPromptPlaceholder()}
            placeholderTextColor="#9ca3af"
            value={situation}
            onChangeText={setSituation}
            multiline
            numberOfLines={6}
            textAlignVertical="top"
          />
          
          <TouchableOpacity 
            style={[
              styles.generateButton,
              { backgroundColor: getModeColor(selectedMode) },
              (isGenerating || !situation.trim() || !aiConfig.apiKey) && styles.generateButtonDisabled
            ]}
            onPress={generateResponse}
            disabled={isGenerating || !situation.trim() || !aiConfig.apiKey}
          >
            {isGenerating ? (
              <ActivityIndicator color="#ffffff" />
            ) : (
              <>
                <Brain size={20} color="#ffffff" />
                <Text style={styles.generateButtonText}>Gerar com IA</Text>
              </>
            )}
          </TouchableOpacity>
        </View>

        {generatedResponse && (
          <View style={styles.resultSection}>
            <View style={styles.resultHeader}>
              <Text style={styles.resultTitle}>Resposta Estratégica</Text>
              <View style={styles.actionButtons}>
                <TouchableOpacity style={styles.actionButton} onPress={saveResponse}>
                  <Save size={16} color="#10b981" />
                </TouchableOpacity>
                <TouchableOpacity style={styles.actionButton} onPress={copyToClipboard}>
                  <Copy size={16} color="#2563eb" />
                </TouchableOpacity>
              </View>
            </View>
            
            <View style={[styles.resultContent, { borderLeftColor: getModeColor(selectedMode) }]}>
              <Text style={styles.resultText}>{generatedResponse}</Text>
            </View>
          </View>
        )}

        <View style={styles.tipCard}>
          <AlertTriangle size={20} color="#f59e0b" />
          <View style={styles.tipContent}>
            <Text style={styles.tipTitle}>Powered by AI</Text>
            <Text style={styles.tipText}>
              Respostas geradas por {aiConfig.provider.toUpperCase()} • Modelo: {aiConfig.model} • 
              Estas sugestões devem ser revistas por profissionais antes de uso.
            </Text>
          </View>
        </View>
      </ScrollView>

      {/* Modal Respostas Guardadas */}
      <Modal
        visible={showSavedModal}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowSavedModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Respostas Guardadas</Text>
              <TouchableOpacity onPress={() => setShowSavedModal(false)}>
                <X size={24} color="#6b7280" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalBody}>
              {savedResponses.length === 0 ? (
                <View style={styles.emptyState}>
                  <AlertTriangle size={48} color="#d1d5db" />
                  <Text style={styles.emptyStateText}>Nenhuma resposta guardada</Text>
                </View>
              ) : (
                savedResponses.map((saved) => (
                  <View key={saved.id} style={styles.savedCard}>
                    <TouchableOpacity 
                      style={styles.savedCardContent}
                      onPress={() => loadResponse(saved)}
                      activeOpacity={0.7}
                    >
                      <View style={styles.savedCardHeader}>
                        <View style={[
                          styles.savedModeBadge, 
                          { backgroundColor: getModeColor(saved.mode) + "20" }
                        ]}>
                          <Text style={[
                            styles.savedModeText, 
                            { color: getModeColor(saved.mode) }
                          ]}>
                            {getModeLabel(saved.mode)}
                          </Text>
                        </View>
                        <Text style={styles.savedCardDate}>
                          {new Date(saved.date).toLocaleDateString("pt-PT", {
                            day: "numeric",
                            month: "short",
                            hour: "2-digit",
                            minute: "2-digit",
                          })}
                        </Text>
                      </View>
                      <Text style={styles.savedCardSituation} numberOfLines={2}>
                        {saved.situation}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={styles.deleteButton}
                      onPress={() => deleteResponse(saved.id)}
                    >
                      <Trash2 size={16} color="#dc2626" />
                    </TouchableOpacity>
                  </View>
                ))
              )}
            </ScrollView>
          </View>
        </View>
      </Modal>

      {/* Modal Configuração IA */}
      <Modal
        visible={showAIConfigModal}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowAIConfigModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Configuração de IA</Text>
              <TouchableOpacity onPress={() => setShowAIConfigModal(false)}>
                <X size={24} color="#6b7280" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalBody}>
              <View style={styles.configSection}>
                <Text style={styles.configLabel}>Provedor de IA</Text>
                <View style={styles.providersGrid}>
                  {providers.map((provider) => (
                    <TouchableOpacity
                      key={provider.id}
                      style={[
                        styles.providerCard,
                        aiConfig.provider === provider.id && styles.providerCardActive
                      ]}
                      onPress={() => updateAIConfig('provider', provider.id)}
                    >
                      <Text style={[
                        styles.providerText,
                        aiConfig.provider === provider.id && styles.providerTextActive
                      ]}>
                        {provider.name}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>

              <View style={styles.configSection}>
                <Text style={styles.configLabel}>Modelo</Text>
                <View style={styles.modelsContainer}>
                  {providers
                    .find(p => p.id === aiConfig.provider)
                    ?.models.map((model) => (
                      <TouchableOpacity
                        key={model}
                        style={[
                          styles.modelButton,
                          aiConfig.model === model && styles.modelButtonActive
                        ]}
                        onPress={() => updateAIConfig('model', model)}
                      >
                        <Text style={[
                          styles.modelText,
                          aiConfig.model === model && styles.modelTextActive
                        ]}>
                          {model}
                        </Text>
                      </TouchableOpacity>
                    ))}
                </View>
              </View>

              <View style={styles.configSection}>
                <Text style={styles.configLabel}>Chave de API</Text>
                <TextInput
                  style={styles.apiKeyInput}
                  placeholder={`Insira sua chave de API ${aiConfig.provider}`}
                  placeholderTextColor="#9ca3af"
                  value={aiConfig.apiKey}
                  onChangeText={(value) => updateAIConfig('apiKey', value)}
                  secureTextEntry
                />
                <Text style={styles.configHelp}>
                  Sua chave é armazenada localmente e nunca enviada para nossos servidores.
                </Text>
              </View>

              <View style={styles.configSection}>
                <Text style={styles.configLabel}>URL da API (Opcional)</Text>
                <TextInput
                  style={styles.apiKeyInput}
                  placeholder="URL base da API"
                  placeholderTextColor="#9ca3af"
                  value={aiConfig.baseURL}
                  onChangeText={(value) => updateAIConfig('baseURL', value)}
                />
              </View>

              <View style={styles.configActions}>
                <TouchableOpacity 
                  style={styles.testButton}
                  onPress={testAIConnection}
                  disabled={!aiConfig.apiKey || isGenerating}
                >
                  {isGenerating ? (
                    <ActivityIndicator color="#ffffff" />
                  ) : (
                    <Text style={styles.testButtonText}>Testar Conexão</Text>
                  )}
                </TouchableOpacity>
                
                <TouchableOpacity 
                  style={styles.saveConfigButton}
                  onPress={() => setShowAIConfigModal(false)}
                >
                  <Text style={styles.saveConfigButtonText}>Guardar Configuração</Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#f9fafb",
  },
  headerButtons: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  headerButton: {
    padding: 4,
  },
  headerButtonText: {
    fontSize: 14,
    fontWeight: "600",
    color: "#2563eb",
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
  },
  header: {
    marginBottom: 24,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
    color: "#6b7280",
    lineHeight: 20,
  },
  configAlert: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    backgroundColor: "#8b5cf6",
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  configAlertText: {
    fontSize: 14,
    fontWeight: "600",
    color: "#ffffff",
  },
  modesGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
    marginBottom: 24,
  },
  modeCard: {
    width: "48%",
    backgroundColor: "#ffffff",
    borderRadius: 12,
    padding: 16,
    borderWidth: 2,
    alignItems: "center",
    gap: 8,
  },
  modeCardActive: {
    backgroundColor: "#f8fafc",
  },
  modeIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: "center",
    justifyContent: "center",
  },
  modeLabel: {
    fontSize: 12,
    fontWeight: "600",
    color: "#6b7280",
    textAlign: "center",
  },
  inputSection: {
    marginBottom: 24,
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: "600",
    color: "#374151",
    marginBottom: 8,
  },
  textArea: {
    backgroundColor: "#ffffff",
    borderRadius: 12,
    padding: 16,
    fontSize: 16,
    color: "#111827",
    minHeight: 150,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 16,
  },
  generateButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    borderRadius: 12,
    paddingVertical: 16,
  },
  generateButtonDisabled: {
    opacity: 0.6,
  },
  generateButtonText: {
    fontSize: 16,
    fontWeight: "600",
    color: "#ffffff",
  },
  resultSection: {
    marginBottom: 24,
  },
  resultHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  resultTitle: {
    fontSize: 16,
    fontWeight: "600",
    color: "#111827",
  },
  actionButtons: {
    flexDirection: "row",
    gap: 8,
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 8,
    backgroundColor: "#f3f4f6",
    alignItems: "center",
    justifyContent: "center",
  },
  resultContent: {
    backgroundColor: "#ffffff",
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    borderLeftWidth: 4,
  },
  resultText: {
    fontSize: 15,
    lineHeight: 24,
    color: "#374151",
  },
  tipCard: {
    flexDirection: "row",
    backgroundColor: "#fef3c7",
    borderRadius: 12,
    padding: 16,
    gap: 12,
    borderLeftWidth: 4,
    borderLeftColor: "#f59e0b",
  },
  tipContent: {
    flex: 1,
  },
  tipTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: "#92400e",
    marginBottom: 4,
  },
  tipText: {
    fontSize: 13,
    lineHeight: 20,
    color: "#78350f",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "flex-end",
  },
  modalContent: {
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: "80%",
  },
  modalHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: "#e5e7eb",
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: "700",
    color: "#111827",
  },
  modalBody: {
    padding: 20,
  },
  emptyState: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 48,
  },
  emptyStateText: {
    fontSize: 16,
    color: "#6b7280",
    marginTop: 16,
  },
  savedCard: {
    flexDirection: "row",
    backgroundColor: "#f9fafb",
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    alignItems: "center",
  },
  savedCardContent: {
    flex: 1,
  },
  savedCardHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 8,
  },
  savedModeBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  savedModeText: {
    fontSize: 11,
    fontWeight: "600",
  },
  savedCardDate: {
    fontSize: 12,
    color: "#6b7280",
  },
  savedCardSituation: {
    fontSize: 14,
    color: "#374151",
    lineHeight: 20,
  },
  deleteButton: {
    width: 36,
    height: 36,
    borderRadius: 8,
    backgroundColor: "#fee2e2",
    alignItems: "center",
    justifyContent: "center",
    marginLeft: 12,
  },
  // Novos estilos para configuração de IA
  configSection: {
    marginBottom: 24,
  },
  configLabel: {
    fontSize: 16,
    fontWeight: "600",
    color: "#374151",
    marginBottom: 12,
  },
  providersGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  providerCard: {
    flex: 1,
    minWidth: "48%",
    backgroundColor: "#f3f4f6",
    borderRadius: 8,
    padding: 12,
    alignItems: "center",
    borderWidth: 2,
    borderColor: "transparent",
  },
  providerCardActive: {
    backgroundColor: "#e0e7ff",
    borderColor: "#6366f1",
  },
  providerText: {
    fontSize: 14,
    fontWeight: "600",
    color: "#6b7280",
  },
  providerTextActive: {
    color: "#6366f1",
  },
  modelsContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  modelButton: {
    backgroundColor: "#f3f4f6",
    borderRadius: 6,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "transparent",
  },
  modelButtonActive: {
    backgroundColor: "#dbeafe",
    borderColor: "#3b82f6",
  },
  modelText: {
    fontSize: 12,
    color: "#6b7280",
  },
  modelTextActive: {
    color: "#1e40af",
    fontWeight: "600",
  },
  apiKeyInput: {
    backgroundColor: "#ffffff",
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: "#111827",
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  configHelp: {
    fontSize: 12,
    color: "#6b7280",
    fontStyle: "italic",
  },
  configActions: {
    gap: 12,
  },
  testButton: {
    backgroundColor: "#10b981",
    borderRadius: 8,
    padding: 16,
    alignItems: "center",
  },
  testButtonText: {
    fontSize: 16,
    fontWeight: "600",
    color: "#ffffff",
  },
  saveConfigButton: {
    backgroundColor: "#3b82f6",
    borderRadius: 8,
    padding: 16,
    alignItems: "center",
  },
  saveConfigButtonText: {
    fontSize: 16,
    fontWeight: "600",
    color: "#ffffff",
  },
});